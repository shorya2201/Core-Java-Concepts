package StaticAndJVM;

class JVM {

    static int a;
    static int b;

    int m;
    int n;

    static {
        a = 10;
        b = 20;
        System.out.println("Control in static block");
    }

    {
        // execute second because of Constructor intialization
        m = 100;
        n = 200;
        System.out.println("Control in non static block");
    }

    static void disp1() {
        System.out.println("Value of static var " + a);
        System.out.println("Value of static var " + b);
    }

    void disp2() {
        System.out.println("Value of non static var " + m);
        System.out.println("Value of non static var " + n);
    }

}

public class StaticJVM {

    public static void main(String[] args) {
        JVM j = new JVM();

        JVM.disp1();
        j.disp2();
        // JVM ARCHITECTURE
        /*
         * # Java is platform independent while JVM is platform dependent
         * # Due to JVM , Java is known as WORA(Write Once Run Anywhere)
         * # JVM is present inside the JRE
         * # JVM is responsible for execution of java program
         * # For execution , the JVM take the BYTE CODE(.class file) & put it inside the
         * JRE
         * # Java is both interpreted and compiled
         * 
         * COMPILE(Compile Time) --> BYTE CODE --> JVM --> INTERPRETER -->
         * EXECUTION(RunTime)
         * 
         * Lifecycle of Java Program [BYTE CODE generated by Compiler & executed by JVM]
         * 
         * a. The Compiler converts the .java file into .class file(BYTE CODE)
         * b. Then the JVM executes the .class file(BYTE CODE)
         * c. The .class file is put in the CLASS LOADER SUB SYSTEM then into the
         * RUNTIME DATA AREAS then into the EXECUTION ENGINE after going through all of
         * these
         * the program finally gets executed.
         * 
         * CLASS LOADER SUB SYSTEM
         * # It takes all of the BYTE CODE(.class files) and put them together
         * 
         * CLASS LOADING :- It is a process of loading class files into the JVM at
         * runtime . It is responsible for loading classes from various sources i.e.
         * databases , Files systems , Network , etc.
         * 
         * It includes 3 major steps :-
         * 
         * 1. LOADING :- Includes loading required libraries from different packages
         * streams etc. It also includes APPLICATION LOADER , BOOTSTRAP LOADER.
         * 
         * 2. LINKING :- Includes three minor steps :
         * VERIFY:- Verify the structure of the code written
         * PREPARE:- If any STATIC variable is present , then it will be initialized
         * with default values.
         * RESOLVE:- To resolve classes and its reference objects . It is a optional
         * stage.
         * 
         * 3. INITIALIZATION :- Includes execution of STATIC block and calling of
         * Constructors if present. Initialize the variables with given or requireed
         * values
         * 
         * RUNTIME DATA AREAS
         * # After loading the classes , Data Areas are created for memory allocation.
         * It consists following areas:
         * 
         * 1. Method Area :- This memory is allocated for class structures, method data
         * and constructor field data, and also for interfaces or special method used in
         * class.
         * 
         * 2. Heap :- Heap space in Java is used for dynamic memory allocation for Java
         * objects and JRE classes at the runtime. New objects are always created in
         * heap space and the references to these objects are stored in stack memory.
         * 
         * 3. Java Stack :- Stack space is mainly used for storing order of method
         * execution and local variables. Stack always stored blocks in LIFO order
         * 
         * 4. PC Register :- The program counter (PC) register is a register in the JVM
         * that stores the address of the instruction currently being executed. It is
         * also known as the instruction pointer (IP) register. The PC register is
         * updated each time an instruction is executed, so that it always points to the
         * next instruction to be executed.
         * 
         * 5. Native Method Stack :- If we use libraries of some other language then the
         * methods of that languages will be stored in the Native Method Stack
         * 
         * EXECUTION ENGINE
         * 1. INTERPRETER
         * # Converts BYTE CODE into Machine Code(0 1)
         * 
         * 2. JIT Compiler
         * # Works as a support for Interpreter to increase speed and efficiency
         * # When a repetitive block of code appears which has to be executed repeatedly
         * without any change , then that block will be executed by JIT Compiler because
         * executing same code block again nd again line by line will be time consuming
         * and slow process.
         * 
         * 3. Garbage Collector
         * # It is responsible for deallocation of memory
         * # When an object is present in the memory and is being referred(pointed) by
         * nothing , then it's memory will be deallocated by Garbage Collector
         * # We dont need to call Garbage Collector explicitly , it will be
         * automatically called when an object with no reference is present.
         */

        // STATIC KEYWORD

        /*
         * 1. Static keyword is mainly used for memory management in java
         * 2. It can be applied with classes , variable , methods , blocks
         * 3. It is property of class rather than instance of class
         * 4. It is used for those variables and methods whose values if same
         * for every instance of a class
         * 
         * # It will be initialized and executed during the process of CLass Loading
         * itself.
         * # To be precise it variable initialization happen in LINKING stage of Class
         * Loading and execution of STATIC BLOCK happens in INITIALIZATION stage of
         * Class Loading.
         * 
         * # Token marked STATIC will be alloted memory at the time of CLASS LOADING
         * # Any token which is marked STATIC will be the first one to initialized and
         * execute.
         * 
         * ORDER OF PRIORITY OF TOKENS IN JAVA PROGRAM
         * 1. STATIC variable
         * 2. STATIC block
         * 3. STATIC method
         * 4. NON-STATIC (instance) variable
         * 5. NON-STATIC block
         * 6. NON-STATIC method
         * 
         */

    }
}